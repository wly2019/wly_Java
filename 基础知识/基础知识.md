<!-- MarkdownTOC -->
-- 摘录自 JavaGuide 

- [1. 面向对象和面向过程的区别](#1-面向对象和面向过程的区别)
  - [面向过程](#面向过程)
  - [面向对象](#面向对象)
- [2. Java 语言有哪些特点](#2-Java-语言有哪些特点)
- [3. 什么是JDK 什么是 JRE 什么是 JVM 三者之间的联系与区别](#3-什么是JDK-什么是-JRE-什么是-JVM-三者之间的联系与区别)
- [4. 什么是字节码 采用字节码的最大好处是什么](#4-什么是字节码-采用字节码的最大好处是什么)
- [5. Java 和 C++ 的区别](#5-Java-和-C++-的区别)
- [6. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同](#6-什么是-Java-程序的主类-应用程序和小程序的主类有何不同)
- [7. Java 应用程序与小程序之间有哪些差别](#7-Java-应用程序与小程序之间有哪些差别)
- [8. 字符型常量和字符串常量的区别](#8-字符型常量和字符串常量的区别)
- [9. 构造器 Constructor 是否可被 override](#9-构造器-Constructor-是否可被-override)
- [10. 重载和重写的区别](#10-重载和重写的区别)
- [11. Java 面向对象编程三大特性：封装、继承、多态](#11-Java-面向对象编程三大特性：封装、继承、多态)
- [12. String 和 StringBuffer、 StringBuilder 的区别是什么 String 为社么是不可变的](#12-String-和-StringBuffer、-StringBuilder-的区别是什么-String-为社么是不可变的)
- [13. 自动装箱与拆箱](#13-自动装箱与拆箱)
- [14. 在一个静态方法内调用要给非静态成员为什么是非法的](#14-在一个静态方法内调用要给非静态成员为什么是非法的)
- [15. 在 Java 中定义一个不做事且没有参数的构造方法的作用](#15-在-Java-中定义一个不做事且没有参数的构造方法的作用)
- [16. import java 和 javax 有什么区别](#16-import-java-和-javax-有什么区别)
- [17. 接口和抽象类的区别是什么](#17-接口和抽象类的区别是什么)
- [18. 成员变量与局部变量的区别](#18-成员变量与局部变量的区别)
- [19. 创建要给对象用什么运算符？ 对象实体与对象引用有何不同？](#19-创建要给对象用什么运算符？-对象实体与对象引用有何不同？)
- [20. 什么是方法的返回值？ 返回值在类的方法里的作用是什么？](#20-什么是方法的返回值？-返回值在类的方法里的作用是什么？)
- [21. 一个类的构造方法的作用是什么？ 若要给类没有声明构造方法，该程序能正确执行么？为什么？](#21-一个类的构造方法的作用是什么？-若要给类没有声明构造方法，该程序能正确执行么？为什么？)
- [22. 构造方法有哪些特性](#22-构造方法有哪些特性)
- [23. 静态方法和实例方法有何不同](#23-静态方法和实例方法有何不同)
- [24. 对象的相当与指向他们的引用相等，两者有什么不同？](#24-对象的相当与指向他们的引用相等，两者有什么不同？)
- [25. 在调用子类构造方法之前会先调用父类没有参数的构造方法，器目的是什么？](#25-在调用子类构造方法之前会先调用父类没有参数的构造方法，器目的是什么？)
- [26. ==与equals](#26-==与equals)
- [27. hashCode 与 equals （重要）](#27-hashCode-与-equals-（重要）)
- [28. ](#28-)
- [29. 简述线程，陈旭、进程的基本概念，以及他们之间关系](#29-简述线程，陈旭、进程的基本概念，以及他们之间关系)
- [30. 线程有哪些状态，这些状态时如何定义的](#30-线程有哪些状态，这些状态时如何定义的)
- [31. 关于final关键字的一些总结](#31-关于final关键字的一些总结)
- [32. Java中的异常处理](#32-Java中的异常处理)
- [33. java 序列化中如果有些字段不想进行序列化怎么办](#33-java-序列化中如果有些字段不想进行序列化怎么办)
- [Java基础学习书籍](#Java基础学习书籍)

<!-- /MarkdownTOC -->
 ## 1. 面向对象和面向过程的区别

 ###面向过程
 **优点：** 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源
 **缺点：** 没有面向对象易维护、易复用、易扩展

 ###面向对象

 **优点：** 易维护、易复用、易扩展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，时系统更加灵活、更加易于维护
 **缺点：** 性能比面向过程低

 ##2. Java 语言有那些特点
 1.简单易学；
 2.面向对象；
 3.平台无关性；
 4.可靠性；
 5.安全性；
 6.支持多线程；
 7.支持网络编程并且很方便；
 8.编译与解释并存；

 ## 3. 什么是JDK 什么是 JRE 什么是 JVM 三者之间的联系与区别
 java 中很基本的东西，
 **JDK：** 给开发者提供开发工具箱，给程序开发者使用。它除了包括完整的JRE（Java Runtime Environment），JAVA 运行环境，还包含了其他共开发者使用的工具包
 **JRE：** 普通用户只需要安装JRE 来运行Java程序。而开发者必须安装JDK来编译、调试程序。
 **JVM：** 当我们运行一个程序时，JVM负责将字节码转换位特定机器代码，JVM提供了内存管理/垃圾回收和安全机制等。这种独立与硬件和操作系统，正式Java程序合一一次编写多处执行的原因。

**区别与联系：**
1. JDK 用户开发，JRE 用户运行Java程序；
2. JDK 和 JRE 中都包含JVM；
3. JVM 是Java 编程语言的核心并且具有平台独立性；

## 4. 什么是字节码 采用字节码的最大好处是什么
### java中的编译器和解释器：
Java 中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个共同的接口

编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来讲虚拟机代码转换为特定系统的机器码执行。
在Java中，这种供虚拟机理解的代码叫做‘字节码’ （即扩展名为‘.class’的文件），它不面向任何特定的处理器，只面向虚拟机。

每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，这也就是结束了Java 的编译与解释并存的特点。

Java 源代码--->编译器---->jvm 可执行的 Java 字节码(即虚拟指令)---->jvm---->jvm 中解释器---->机器可执行的二进制机器码---->程序运行。

###采用字节码的好处：

**Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无需重新编译便可在多种不同的计算级上运行**

解释性语言：是在运行的是偶将程序翻译成机器语言。解释性语言的程序不需要在运行前编译，在运行程序的时候才翻译，专门的解释器负责在每个语句执行的时候解释程序代码。这样解释型语言每执行一次就要翻译一次，效率比较低。


## 5. Java 和 C++ 的区别

- 都是面向对象的语言，都支持封装、继承和多态
- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；Java 的类不可以多继承，但是接口可以多继承
- Java 又自动内存管理机制，不需要程序员手动释放无用内存


## 6. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同

一个程序中可以有多个类，但只能有一个类是主类。在Java 应用程序中，这个主类是只包含 main() 方法的类。而在 Java 小程序中，这个主类是一个继承自系统类JApplet 或Applet 的自类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java 程序执行的入口点。


## 7. Java 应用程序与小程序之间有哪些差别

简单说应用程序是从主线程启动（业绩是main()方法）。applet 小程序没有main方法，主要是嵌在浏览器页面上运行（调用init()线程或者run()来启动）。

## 8. 字符型常量和字符串常量的区别

1. 形式上：字符常量是单引号引起的一个字符，字符串常量是双引号引起的若干个字符
2. 含义上：字符常量相当于一个整形值（ASCII值），可以参加表达式运算；字符串常量代表一个地址值（该字符串在内存中存放位置）
3. 占内存大小：字符常量只占2个字节；字符串常量占若干个字节（char在Java中占两个字节）


## 9. 构造器 Constructor 是否可被 override

在继承中，我们知道父类的私有属性和构造方法不能被继承，所以 Constructor 也就不能被 override（重写），但是可以 overload（重载），所以可以看到要给类中有多个构造函数的情况。

## 10. 重载和重写的区别

**重载：** 发生在一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。
**重写：** 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private 则自类就不能重写该方法。

## 11 Java 面向对象编程三大特性：封装、继承、多态
###封装
 封装是把一个对象的属性私有化，同时提供一些可以被外界访问的属性和方法，如果属性不想被外界访问，可以不提供方法给外界，但是如果一个类没有提供给外界访问的方法，那么这个类也就没有意义了。
 
###继承

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性的继承父类。通过使用继承可以非常方便的复用以前的代码。

**关于继承记住一下3点：**

1. 子类拥有父类非 private 的属性和方法。
2. 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。

###多态

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向那个类的实例对象，该引用变量发出的方法调用到底那个类中实现的方法，必须在由程序运行期间才能决定。

在Java 中由两种形式可以实现多态：继承（多个子类对统一方法的重写）和接口（实现接口并覆盖接口中同一方法）。



## 12. String 和 StringBuffer、 StringBuilder 的区别是什么 String 为社么是不可变的

**可变性**
简单的来说： String 类中使用final 关键子字符数组保存字符串， private final char value[] ，所以String对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用final 关键字修饰，所以这两种对象都是可变的。

StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法，也就是 AbstractStringBuilder 实现的，
可以自行查阅源码： AbstractStringBuilder.java
```java
abstract class AbstractStringBuilder implements Appendable, CharSequence {
    char[] value;
    int count;
    AbstractStringBuilder(){}
    AbstractStringBuilder(int capacity){value = new char[capacity];}
}
```

**线程安全性**

String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公告父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。 StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

**性能**

每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的String 对象。String Builder 每次都会对 StringBuilder 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

**对于三者使用的总结：**
1. 操作少量的数据 ：String
2. 单线程操作字符串缓冲区下操作大量数据 ：StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据 ：StringBuffer

##13. 自动装箱与拆箱

**装箱**：将基本类型用他们对应的引用类型包装起来；

**拆箱**：将包装类型转换为基本数据类型；

##14. 在一个静态方法内调用要给非静态成员为什么是非法的

由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。



##15。 在 Java 中定义一个不做事且没有参数的构造方法的作用

Java 程序在执行自类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了又参数的构造方法，而在i之类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法时在父类里加上一个不做事且没有参数的构造方法。




##16。 import java 和 javax 有什么区别

刚开始的时候 JavaApiece 所必须的包是 Java 开头的包，Javax 当时只是扩展 API 包来使用。然后随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从javax 包移动到 Java包僵尸太麻烦了，最终会破坏一堆现有的代码，因此，最终决定javax 包将成为标准API的一部分。
所以，实际上，Java和javax没有区别。

## 17. 接口和抽象类的区别是什么
1. 接口的方法默认是public，所有方法在接口中不能又实现（Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法。
2. 接口中的实力变量默认是final类型的，而抽象类中不一定
3. 一个类可以实现多个接口，但最多只能实现要给抽象类
4. 一个类实现接口的话要实现接口的所有方法，而抽象类不一定
5. 接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象。从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。


## 18. 成员变量与局部变量的区别

1. 从语法形式上，成员变量属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public、private、static 等修饰符所修饰，而局部变量不能被访问控制修饰符及static 所修饰， 但是成员变量和局部变量都能被 final 所修饰；
2. 从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在与堆内存，局部变量存在与栈内存；
3. 从变量在内存中的生存时间上看，成员变量是对象的一部分，他随着对象的创建而存在，而局部变量随着方法的调用而自动消失；
4. 成员变量如果没有被复制，则会自动以类型的默认值而复制（例外：被final 修饰但没有被statistical 修饰的成员变量必须显示的赋值）；而局部变量则不会自动赋值。

## 19. 创建要给对象用什么运算符？ 对象实体与对象引用有何不同？

new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存）。一个对象引用可以指向0个或1个对象；一个对象可以有n个引用指向它。

## 20. 什么是方法的返回值？ 返回值在类的方法里的作用是什么？
方法的返回值是我们获取到的某个方法体中的代码执行后产生的结果。
返回值的作用：接受结果用于其他操作。

## 21. 一个类的构造方法的作用是什么？ 若要给类没有声明构造方法，该程序能正确执行么？为什么？
主要作用是完成类对象的初始化工作。
可以执行；
因为一个类即使没有声明构造方法也会有默认无参构造方法。

## 22. 构造方法有哪些特性

1. 名字与类名相同；
2. 没有返回值，但不能用void声明构造函数；
3.生成类的独享是自动执行，无需调用。

## 23. 静态方法和实例方法有何不同

1. 在外部调用静态方法时，可以使用“类名.方法名”的方式，也可以使用“对象名.方法名”的方式。
    而实例方法只有后面这种方式。即：调用静态方法可以无需创建对象。
2. 静态方法在访问本类的成员时，只运行访问静态成员，而不允许访问实例成员变量和实例方法；实例方法无此限制。

## 24. 对象的相当与指向他们的引用相等，两者有什么不同？

对象的相等，比较的时内存中存放的内容是否相等。而引用相等，比较的时他们指向的内存地址是否相等。

## 25. 在调用子类构造方法之前会先调用父类没有参数的构造方法，器目的是什么？
帮助子类做初始化工作。

## 26. ==与equals
**==**：作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。（基本数据类型==比较的是值，引用数据类型==比较的是内存地址）

**equals**：作用是判断两个对象是否相等。
    但一般有两种使用情况：
- 1：类没有覆盖equals()方法：则通过equals()比较该类的两个对象时，等价与通过“==”比较这两个对象。
- 2：类覆盖了equals()方法：一般覆盖equals()方法来比较两个对象的内容相等；若他们的内容相等，返回true。

说明：
- string 中equals 方法是被重写过的，
因为object的equals 方法比较的是对象的内存地址，而string 的equals方法比较的是对象的值。
- 当创建string类型的对象时，虚拟机会在常量池中查找是否有已存在的值和要创建的值相同的对象，如果有就把它赋值给当前引用，如果没有就在常量池中重新创建一个string对象。





## 27. hashCode 与 equals （重要）
###hashCode 介绍
hashCode的作用是获取哈希码，也成为散列码，它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。
hashCode()定义在JDK的object.java中，这意味着Java中的任何类都包含有hashcode()函数。

散列表存储的是键值对key-value ，它的特点是：能根据“键”快速的检索出对应的“值”。
这其中就利用到了散列码

###为什么要有hashCode

以“hashSet 如何检查重复”为例子来说明为什么要有hashCode:

当把对象加入hashset 时，会先计算对象的hashCOde 值来判断对象加入的位置，同时也会与其他已经加入的对象的hashCode值作比较，如果没有相符的hashcode，hashset会假设对象没有重复出现。
但是如果发现有相同hashcode值的对象，这是会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，hashset 就不会让其加入操作成功。如果不同，就会重新散列到其他位置。
这样就大大减少了equals的次数，相应就大大提高了执行速度。

### hashCode() 与 equals() 的相关规定

1. 如果两个对象相等，则hashcode 一定也是相同的
2. 两个对象相等，对两个对象分别调用equals方法都返回true
3. 两个对象有相同的hashcode值，他们也不一定是相等的
4.因此，equals 方法被覆盖过，则hasehcode方法也必须被覆盖
5. hashcode()的默认行为是对堆上的对象产生独特值。如果没有重写hashcode()，则该class的两个对象无论如何都不会相等






## 29. 简述线程，陈旭、进程的基本概念，以及他们之间关系

线程与进程相似，但线程是要给币进程更小的执行单位。
一个进程在其执行的过程中可以产生多个线程。
与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小的多，因为此，线程被称为轻量级进程。

程序是含有质粒和数据的文件，被存储在磁盘或其他的数据存储设备中，即，程序是静态的代码。

进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。
系统运行一个程序即使一个进程从创建、运行、到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算级中一个指令接着一个指令的执行着，
同时，每个进程还占有某些系统资源入CPU时间，内存空间，文件，输入输出设备的使用权等。
即当程序在执行时，将会被操作系统载入内存中。
线程时进程划分成的更小的运行单位。
线程和进程最大的不同在于基本上个进程时独立的，而各线程则不一定，因为同一进程中的线程有可能会相互影响。
从另一角度来说，进程属于操作系统的范畴，主要时同一个段时间内，可以同时执行要给以上的程序，而线程则是在同一 程序内几乎同时执行一个以上的程序段。

## 30. 线程有哪些状态，这些状态时如何定义的

1. 新建(new) : 新创建了一个线程对象。
2. 可运行（runnable）：线程对象创建后，其他线程调用了该对象的start（）方法。该状态的线程位于可运行线程池中，等待被线程调度选择，获取CPU的使用权。
3. 运行（running）：可运行状态的线程获得了CPU时间片（timeslice），执行程序代码。
4. 阻塞（block）：阻塞状态是指线程因为某种原因放弃了cpu使用权，即让出了cpu  timeslice，暂时停止运行。
知道线程进入可运行（runnable）状态，才有机会再次获得cpu timeslice 转到运行（running）状态。
阻塞有三种情况：
    - 等待阻塞：
    - 同步阻塞：
    - 其他阻塞：
5. 死亡（dead）：线程run()、main() 方法执行结束，或者因异常退出了run（）方法，则线程结束生命周期
死亡的线程不可再次复生。  



## 31. 关于final关键字的一些总结

final 主要用在三个地方：变量、方法、类

1. 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
2. 当用final 修饰一个类时，表面这个类不能被继承。
final 类中的所有成员方法都会被隐式的指定为final方法。
3. 使用final方法的原因有两个，一个原因是把方法锁定，以防止任何继承类修改它的含义；第二个是效率。
在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用嗲来的任何性能提升
类中所有的private方法都隐式的指定为final

## 32. Java中的异常处理

在Java中，所有的异常都有一个共同的祖先Java.lang包中的throwable类。
throwable:有两个重要的子类：exception 和 error ，

- error（错误）：是程序无法处理的错误，表示运行应用程序中较为严重问题。
大多数错误与代码辨析着执行的操作无关，而表示代码运行时jvm出现的问题。

- exception（异常）：是程序本身可以处理的异常。
exception类有一个重要的子类runtimeexception.
runtimeException 异常有Java虚拟机抛出。
NullPointerException （要访问的变量没有引用任何对象时，抛出该异常）
ArithmeticException （算术运算异常，一个整数除以0时，抛出该异常）
ArrayIndexOutOfBoundsException（下标越界异常）

异常能被程序本身处理，错误是无法处理。

**Throwable 类常用方法**
- public string getMessage():返回异常时的详细信息
- public string toString():返回异常时的简要描述
- public string getLocalizedMessage():返回异常对象的本地化信息，使用它Throwable的子类覆盖这个方法，可以声称本地化信息。
如果子类没有覆盖该方法，则该方法返回的信息与getMessage() 返回的结果相同。
- public void printStackTrace():在控制台上打印Throwable对象封装的异常信息

**异常处理总结**
- try块：用于捕获异常。
- catch块：用户处理try捕获到的异常。
- finally块：无论是否捕获或处理异常，finally块里的语句都会被执行。
当在try块或者catch块中遇到return语句时，finally语句块将在方法返回之前被执行。

在以下4中特殊情况下，finally块不会被执行：
- 在finally语句块中发生了异常
- 在前面的代码中用了system.exit()退出程序
- 程序所在的线程死亡
- 关闭cpu


## 33. java 序列化中如果有些字段不想进行序列化怎么办

对于不想进行序列化的变量，可以使用transient关键字修饰

transient关键字的作用是：阻止实例中哪些用此关键字修饰的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复
transient只能修饰变量，不能修饰类和方法。

##Java基础学习书籍

《Head First Java 第二版》  适合新手

《Java核心技术卷1+卷2》 比较深入

《Java编程思想（第四版）》 要常读的书。






















